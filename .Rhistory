# COVID
met_covid <- metrics_by_mask(sel_cols, mask_covid, "COVID(2020-02-20..2020-09-30)")
# Regimes SELIC
met_regimes <- dplyr::bind_rows(lapply(levels(regime_selic), function(lv) {
metrics_by_mask(sel_cols, regime_selic == lv, paste0("SELIC_", lv))
}))
# Consolida e salva
metrics_stress <- dplyr::bind_rows(met_covid, met_regimes) |>
dplyr::arrange(grupo, dplyr::desc(sharpe))
readr::write_csv(metrics_stress, "results/tables/metrics_stress_windows.csv")
# ---- IC por Bootstrap (completo e robusto) -> results/tables ----
dir.create("results/tables", recursive = TRUE, showWarnings = FALSE)
# Config padrão
if (!exists("cfg")) cfg <- list()
if (is.null(cfg$bootstrap_B)) cfg$bootstrap_B <- 500L
if (is.null(cfg$block_len))   cfg$block_len   <- 10L
# Métricas mínimas (define se ausentes)
if (!exists("ann_ret")) ann_ret <- function(x) { x <- as.numeric(x); exp(mean(x, na.rm = TRUE) * 252) - 1 }
if (!exists("sharpe"))  sharpe  <- function(x) { x <- as.numeric(x); m <- mean(x, na.rm = TRUE); s <- stats::sd(x, na.rm = TRUE); if (!is.finite(s) || s == 0) NA_real_ else m / s * sqrt(252) }
if (!exists("mdd"))     mdd     <- function(x) { idx <- exp(cumsum(replace(as.numeric(x), !is.finite(x), 0))); min(idx / cummax(idx) - 1, na.rm = TRUE) }
# Índices para moving-block bootstrap
.mb_indices <- function(n, B, b) {
b <- max(1L, min(as.integer(b), n))
k <- ceiling(n / b)
starts <- matrix(sample.int(n - b + 1L, B * k, replace = TRUE), nrow = B)
idx <- t(apply(starts, 1, function(st) {
id <- unlist(lapply(st, function(s) seq.int(s, length.out = b)))
id[seq_len(n)]
}))
idx
}
# Bootstrap das métricas
bootstrap_metrics <- function(x, B = cfg$bootstrap_B, b = cfg$block_len) {
x <- as.numeric(x); n <- length(x)
if (n < 5L) return(tibble::tibble(ann_ret_lo = NA_real_, ann_ret_hi = NA_real_, sharpe_lo = NA_real_, sharpe_hi = NA_real_, mdd_lo = NA_real_, mdd_hi = NA_real_))
idx_mat <- .mb_indices(n, B, b)
sret <- vapply(seq_len(B), function(i) ann_ret(x[idx_mat[i, ]]), numeric(1))
ssrp <- vapply(seq_len(B), function(i) sharpe(x[idx_mat[i, ]]),   numeric(1))
smdd <- vapply(seq_len(B), function(i) mdd(x[idx_mat[i, ]]),      numeric(1))
tibble::tibble(
ann_ret_lo = quantile(sret, 0.025, na.rm = TRUE),
ann_ret_hi = quantile(sret, 0.975, na.rm = TRUE),
sharpe_lo  = quantile(ssrp, 0.025, na.rm = TRUE),
sharpe_hi  = quantile(ssrp, 0.975, na.rm = TRUE),
mdd_lo     = quantile(smdd, 0.025, na.rm = TRUE),
mdd_hi     = quantile(smdd, 0.975, na.rm = TRUE)
)
}
# Seleção de séries
stopifnot(exists("ret_cost"), exists("ret_bench"), "ret_bh" %in% names(ret_bench))
custos_alvo <- c(0, 10, 25)
vt_cost_cols <- grep("^ret_.*_c\\d+$",   names(ret_cost),  value = TRUE)
ew_cost_cols <- grep("^retEW_.*_c\\d+$", names(ret_bench), value = TRUE)
pick_by_cost <- function(cols, custos) {
patt <- paste0("_c(", paste(sprintf("%02d", custos), collapse = "|"), ")$")
grep(patt, cols, value = TRUE)
}
sel_cols <- c(
"ret_bh",
pick_by_cost(vt_cost_cols, custos_alvo),
pick_by_cost(ew_cost_cols, custos_alvo)
)
get_series <- function(nm) {
if (nm == "ret_bh") return(ret_bench[[nm]])
if (nm %in% names(ret_cost))  return(ret_cost[[nm]])
if (nm %in% names(ret_bench)) return(ret_bench[[nm]])
stop("Série não encontrada: ", nm)
}
ci_rows <- lapply(sel_cols, function(nm) cbind.data.frame(serie = nm, bootstrap_metrics(get_series(nm))))
ci_tbl  <- dplyr::bind_rows(ci_rows)
readr::write_csv(ci_tbl, "results/tables/ci_bootstrap_metrics.csv")
# ---- Sensibilidade de parâmetros + Margem/Turnover -> results/tables ----
dir.create("results/tables", recursive = TRUE, showWarnings = FALSE)
# Helpers de parsing
.parse_cap <- function(x) as.numeric(sub(".*cap(\\d+).*", "\\1", x)) / 10
.parse_tgt <- function(x) as.numeric(sub(".*?(\\d{2})a.*", "\\1", x)) / 100
.parse_cost <- function(x) {
m <- regmatches(x, regexpr("_c\\d+$", x))
ifelse(nchar(m) > 0, as.integer(sub("_c", "", m)), 0L)
}
parse_ret_name <- function(nm) {
if (nm == "ret_bh") {
return(tibble::tibble(serie = nm, modelo = "BH", alvo_aa = NA_real_, cap = 1.0, cost_bps = 0L))
}
if (grepl("^retEW_", nm)) {
tibble::tibble(
serie = nm, modelo = "VT_EWMA",
alvo_aa = .parse_tgt(nm), cap = .parse_cap(nm), cost_bps = .parse_cost(nm)
)
} else if (grepl("^ret_", nm)) {
tibble::tibble(
serie = nm, modelo = "VT",
alvo_aa = .parse_tgt(nm), cap = .parse_cap(nm), cost_bps = .parse_cost(nm)
)
} else {
tibble::tibble(serie = nm, modelo = NA_character_, alvo_aa = NA_real_, cap = NA_real_, cost_bps = NA_integer_)
}
}
# Conecta parâmetros às métricas já calculadas
stopifnot(exists("metrics_all"))
params_tbl <- dplyr::bind_rows(lapply(metrics_all$serie, parse_ret_name))
sens_tbl <- metrics_all |>
dplyr::left_join(params_tbl, by = "serie") |>
dplyr::relocate(modelo, alvo_aa, cap, cost_bps, .after = serie)
# Tabulação completa de sensibilidade
readr::write_csv(sens_tbl, "results/tables/sensitivity_full.csv")
# Melhores por custo e cap (maior Sharpe)
best_cost_cap <- sens_tbl |>
dplyr::filter(!is.na(cap), !is.na(cost_bps)) |>
dplyr::group_by(modelo, cost_bps, cap) |>
dplyr::slice_max(order_by = sharpe, n = 1, with_ties = FALSE) |>
dplyr::ungroup()
readr::write_csv(best_cost_cap, "results/tables/sensitivity_best_by_cost_cap.csv")
# Melhores por custo (ignorando cap)
best_cost <- sens_tbl |>
dplyr::filter(!is.na(cost_bps)) |>
dplyr::group_by(modelo, cost_bps) |>
dplyr::slice_max(order_by = sharpe, n = 1, with_ties = FALSE) |>
dplyr::ungroup()
readr::write_csv(best_cost, "results/tables/sensitivity_best_by_cost.csv")
# ---- Uso de margem e turnover por estratégia (pesos) ----
stopifnot(exists("weights_df"))
if (!exists("weights_ew")) weights_ew <- tibble::tibble(data = weights_df$data) # garante objeto
summarize_weights <- function(df, kind = c("VT","VT_EWMA")) {
kind <- match.arg(kind)
nm_cols <- setdiff(names(df), "data")
out <- lapply(nm_cols, function(nm) {
w <- df[[nm]]
tibble::tibble(
serie_peso = nm,
modelo = kind,
alvo_aa = .parse_tgt(nm),
cap     = .parse_cap(nm),
pct_dias_w_gt1 = mean(w > 1, na.rm = TRUE),
w_max   = max(w, na.rm = TRUE),
w_med   = mean(w, na.rm = TRUE)
)
})
dplyr::bind_rows(out)
}
margin_vt  <- summarize_weights(weights_df,  "VT")
margin_ew  <- summarize_weights(weights_ew,  "VT_EWMA")
margin_all <- dplyr::bind_rows(margin_vt, margin_ew)
# Turnover: mediana e p95
stopifnot(exists("turnover"))
if (!exists("to_ew")) to_ew <- tibble::tibble(data = weights_df$data)
turn_summary <- function(turn_df, modelo_prefix = c("to_", "toEW_"), kind = c("VT","VT_EWMA")) {
modelo_prefix <- match.arg(modelo_prefix)
kind <- match.arg(kind)
nm_cols <- grep(paste0("^", modelo_prefix), names(turn_df), value = TRUE)
dplyr::bind_rows(lapply(nm_cols, function(nm) {
to <- turn_df[[nm]]
# nome do peso correspondente
peso_nm <- if (modelo_prefix == "to_") sub("^to_", "w_", nm) else sub("^toEW_", "wEW_", nm)
tibble::tibble(
serie_turnover = nm,
serie_peso     = peso_nm,
modelo         = kind,
alvo_aa        = .parse_tgt(peso_nm),
cap            = .parse_cap(peso_nm),
to_median      = stats::median(to, na.rm = TRUE),
to_p95         = stats::quantile(to, 0.95, na.rm = TRUE),
to_mean        = mean(to, na.rm = TRUE)
)
}))
}
to_vt <- turn_summary(turnover, "to_",   "VT")
to_ew <- turn_summary(to_ew,    "toEW_", "VT_EWMA")
to_all <- dplyr::bind_rows(to_vt, to_ew)
# Une margem e turnover
margin_turn <- margin_all |>
dplyr::left_join(to_all, by = c("modelo","alvo_aa","cap","serie_peso"))
readr::write_csv(margin_all, "results/tables/margin_usage.csv")
readr::write_csv(to_all,     "results/tables/turnover_summary.csv")
readr::write_csv(margin_turn,"results/tables/margin_and_turnover.csv")
# ---- Sensibilidade de parâmetros + Margem/Turnover (com correções) -> results/tables ----
dir.create("results/tables", recursive = TRUE, showWarnings = FALSE)
# Parsers robustos
.parse_cap <- function(x) ifelse(grepl("cap(\\d+)", x),
as.numeric(sub(".*cap(\\d+).*", "\\1", x))/10, NA_real_)
.parse_tgt <- function(x) ifelse(grepl("(\\d{2})a", x),
as.numeric(sub(".*?(\\d{2})a.*", "\\1", x))/100, NA_real_)
.parse_cost <- function(x) {
m <- regmatches(x, regexpr("_c\\d+$", x))
ifelse(nchar(m) > 0, as.integer(sub("_c", "", m)), 0L)
}
parse_ret_name <- function(nm) {
if (nm == "ret_bh") {
return(tibble::tibble(serie = nm, modelo = "BH", alvo_aa = NA_real_, cap = 1.0, cost_bps = 0L))
}
if (grepl("^retEW_", nm)) {
tibble::tibble(
serie = nm, modelo = "VT_EWMA",
alvo_aa = .parse_tgt(nm), cap = .parse_cap(nm), cost_bps = .parse_cost(nm)
)
} else if (grepl("^ret_", nm)) {
tibble::tibble(
serie = nm, modelo = "VT",
alvo_aa = .parse_tgt(nm), cap = .parse_cap(nm), cost_bps = .parse_cost(nm)
)
} else {
tibble::tibble(serie = nm, modelo = NA_character_, alvo_aa = NA_real_, cap = NA_real_, cost_bps = NA_integer_)
}
}
# Conecta parâmetros às métricas (sem many-to-many)
stopifnot(exists("metrics_all"))
params_tbl <- dplyr::bind_rows(lapply(unique(metrics_all$serie), parse_ret_name)) |>
dplyr::distinct(serie, .keep_all = TRUE)
sens_tbl <- metrics_all |>
dplyr::left_join(params_tbl, by = "serie") |>
dplyr::relocate(modelo, alvo_aa, cap, cost_bps, .after = serie)
readr::write_csv(sens_tbl, "results/tables/sensitivity_full.csv")
# Melhores por custo e cap
best_cost_cap <- sens_tbl |>
dplyr::filter(!is.na(cap), !is.na(cost_bps)) |>
dplyr::group_by(modelo, cost_bps, cap) |>
dplyr::slice_max(order_by = sharpe, n = 1, with_ties = FALSE) |>
dplyr::ungroup()
readr::write_csv(best_cost_cap, "results/tables/sensitivity_best_by_cost_cap.csv")
# Melhores por custo (ignorando cap)
best_cost <- sens_tbl |>
dplyr::filter(!is.na(cost_bps)) |>
dplyr::group_by(modelo, cost_bps) |>
dplyr::slice_max(order_by = sharpe, n = 1, with_ties = FALSE) |>
dplyr::ungroup()
readr::write_csv(best_cost, "results/tables/sensitivity_best_by_cost.csv")
# ---- Uso de margem e turnover por estratégia (pesos) ----
stopifnot(exists("weights_df"))
if (!exists("weights_ew")) weights_ew <- tibble::tibble(data = weights_df$data) # garante objeto
summarize_weights <- function(df, kind = c("VT","VT_EWMA")) {
kind <- match.arg(kind)
nm_cols <- setdiff(names(df), "data")
out <- lapply(nm_cols, function(nm) {
w <- df[[nm]]
tibble::tibble(
serie_peso = nm,
modelo = kind,
alvo_aa = .parse_tgt(nm),
cap     = .parse_cap(nm),
pct_dias_w_gt1 = mean(w > 1, na.rm = TRUE),
w_max   = max(w, na.rm = TRUE),
w_med   = mean(w, na.rm = TRUE)
)
})
dplyr::bind_rows(out)
}
margin_vt  <- summarize_weights(weights_df,  "VT")
margin_ew  <- summarize_weights(weights_ew,  "VT_EWMA")
margin_all <- dplyr::bind_rows(margin_vt, margin_ew)
# Turnover: mediana, média e p95
stopifnot(exists("turnover"))
if (!exists("to_ew")) to_ew <- tibble::tibble(data = weights_df$data)
turn_summary <- function(turn_df, modelo_prefix = c("to_", "toEW_"), kind = c("VT","VT_EWMA")) {
modelo_prefix <- match.arg(modelo_prefix)
kind <- match.arg(kind)
nm_cols <- grep(paste0("^", modelo_prefix), names(turn_df), value = TRUE)
dplyr::bind_rows(lapply(nm_cols, function(nm) {
to <- turn_df[[nm]]
peso_nm <- if (modelo_prefix == "to_") sub("^to_", "w_", nm) else sub("^toEW_", "wEW_", nm)
tibble::tibble(
serie_turnover = nm,
serie_peso     = peso_nm,
modelo         = kind,
alvo_aa        = .parse_tgt(peso_nm),
cap            = .parse_cap(peso_nm),
to_median      = stats::median(to, na.rm = TRUE),
to_p95         = stats::quantile(to, 0.95, na.rm = TRUE),
to_mean        = mean(to, na.rm = TRUE)
)
}))
}
to_vt <- turn_summary(turnover, "to_",   "VT")
to_ew <- turn_summary(to_ew,    "toEW_", "VT_EWMA")
to_all <- dplyr::bind_rows(to_vt, to_ew)
# Une margem e turnover
margin_turn <- margin_all |>
dplyr::left_join(to_all, by = c("modelo","alvo_aa","cap","serie_peso"))
readr::write_csv(margin_all, "results/tables/margin_usage.csv")
readr::write_csv(to_all,     "results/tables/turnover_summary.csv")
readr::write_csv(margin_turn,"results/tables/margin_and_turnover.csv")
# ---- Figuras principais -> saídas/Gráficos ----
fig_dir <- file.path("saídas","Gráficos")
dir.create(fig_dir, recursive = TRUE, showWarnings = FALSE)
if (!requireNamespace("ggplot2", quietly = TRUE)) {
install.packages("ggplot2", dependencies = TRUE, repos = "https://cran.rstudio.com")
}
if (!requireNamespace("zoo", quietly = TRUE)) {
install.packages("zoo", dependencies = TRUE, repos = "https://cran.rstudio.com")
}
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(zoo))
eq_idx <- function(r) exp(cumsum(replace(as.numeric(r), !is.finite(r), 0)))
roll_vol_63 <- function(r) sqrt(252) * zoo::rollapplyr(as.numeric(r), 63, sd, na.rm = TRUE, fill = NA)
get_series <- function(nm) {
if (nm == "ret_bh") return(ret_bench[[nm]])
if (nm %in% names(ret_cost))  return(ret_cost[[nm]])
if (nm %in% names(ret_df))    return(ret_df[[nm]])
if (nm %in% names(ret_bench)) return(ret_bench[[nm]])
stop("Série não encontrada: ", nm)
}
weight_name_from_ret <- function(nm) {
if (grepl("^retEW_", nm)) return(sub("^retEW_", "wEW_", nm))
if (grepl("^ret_", nm))   return(sub("^ret_",   "w_",   nm))
NA_character_
}
pick_best <- function(group_pattern, cost_suffix = "_c10$") {
cand <- metrics_all |>
dplyr::filter(grepl(group_pattern, grupo),
grepl(cost_suffix, serie))
if (!nrow(cand)) cand <- metrics_all |>
dplyr::filter(grepl(group_pattern, grupo))
if (!nrow(cand)) return(NA_character_)
cand$serie[which.max(cand$sharpe)]
}
best_vt <- pick_best("^VT_c/ct")
best_ew <- pick_best("^VT_EWMA_c/ct")
bh_name <- "ret_bh"
stopifnot(bh_name %in% names(ret_bench))
series_pick <- unique(na.omit(c(bh_name, best_vt, best_ew)))
if (length(series_pick) < 2) {
vt_any <- grep("^ret_", names(ret_cost), value = TRUE)
series_pick <- unique(c(bh_name, head(vt_any, 1)))
}
# Curvas de capital
df_eq <- tibble::tibble(data = base_ext$data)
for (nm in series_pick) df_eq[[nm]] <- eq_idx(get_series(nm))
df_long <- tidyr::pivot_longer(df_eq, -data, names_to = "serie", values_to = "idx")
p_eq <- ggplot(df_long, aes(x = data, y = idx, color = serie)) +
geom_line(linewidth = 0.8) +
labs(title = "Curvas de capital (base 1)", x = NULL, y = "Índice acumulado") +
theme_minimal(base_size = 11) + theme(legend.title = element_blank())
ggsave(file.path(fig_dir, "equity_curves.png"), p_eq, width = 10, height = 5, dpi = 120)
# Volatilidade rolling 63d
df_vol <- tibble::tibble(data = base_ext$data)
for (nm in series_pick) df_vol[[nm]] <- roll_vol_63(get_series(nm))
dfv_long <- tidyr::pivot_longer(df_vol, -data, names_to = "serie", values_to = "vol_a")
p_vol <- ggplot(dfv_long, aes(x = data, y = vol_a, color = serie)) +
geom_line(linewidth = 0.7) +
labs(title = "Volatilidade anualizada rolling (63 dias)", x = NULL, y = "Vol 63d (a.a.)") +
theme_minimal(base_size = 11) + theme(legend.title = element_blank())
ggsave(file.path(fig_dir, "vol_rolling_63d.png"), p_vol, width = 10, height = 5, dpi = 120)
# Pesos da melhor VT
best_vt_w <- weight_name_from_ret(best_vt)
if (!is.na(best_vt_w) && best_vt_w %in% names(weights_df)) {
cap_num <- {
m <- regmatches(best_vt_w, regexpr("cap(\\d+)", best_vt_w))
ifelse(length(m) && nchar(m) > 0, as.numeric(sub("cap", "", m))/10, NA_real_)
}
df_w <- tibble::tibble(data = weights_df$data, w = weights_df[[best_vt_w]])
p_w <- ggplot(df_w, aes(x = data, y = w)) +
geom_line(linewidth = 0.7, color = "#2C7FB8") +
{ if (is.finite(cap_num)) geom_hline(yintercept = cap_num, linetype = 2) else NULL } +
labs(title = paste0("Peso da estratégia: ", best_vt_w), x = NULL, y = "w_t") +
theme_minimal(base_size = 11)
ggsave(file.path(fig_dir, "weights_best_vt.png"), p_w, width = 10, height = 4.5, dpi = 120)
}
# Drawdown BH vs melhor VT
dd_from_ret <- function(r) { idx <- eq_idx(r); idx / cummax(idx) - 1 }
df_dd <- tibble::tibble(data = base_ext$data, BH = dd_from_ret(get_series(bh_name)))
if (!is.na(best_vt)) df_dd$VT <- dd_from_ret(get_series(best_vt))
dfdd_long <- tidyr::pivot_longer(df_dd, -data, names_to = "serie", values_to = "dd")
p_dd <- ggplot(dfdd_long, aes(x = data, y = dd, color = serie)) +
geom_line(linewidth = 0.7) +
labs(title = "Drawdown ao longo do tempo", x = NULL, y = "DD") +
scale_y_continuous(labels = scales::percent) +
theme_minimal(base_size = 11) + theme(legend.title = element_blank())
ggsave(file.path(fig_dir, "drawdowns.png"), p_dd, width = 10, height = 5, dpi = 120)
source("G:/My Drive/Faculdade/6 Periodo/Análise Quantitativa/Trabalho Final/GARCHBOVA11/Alvo_Volatilidade_GARCH.R", echo = TRUE)
source("G:/My Drive/Faculdade/6 Periodo/Análise Quantitativa/Trabalho Final/GARCHBOVA11/Alvo_Volatilidade_GARCH.R", echo = TRUE)
if (!requireNamespace("rugarch", quietly = TRUE)) {
install.packages("rugarch", dependencies = TRUE, repos = "https://cran.rstudio.com")
}
suppressPackageStartupMessages(library(rugarch))
.egarch_spec <- function(dist = c("norm","std")) {
dist <- match.arg(dist)
ugarchspec(
variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
mean.model     = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = dist
)
}
.gjr_spec <- function(dist = c("norm","std")) {
dist <- match.arg(dist)
ugarchspec(
variance.model = list(model = "gjrGARCH", garchOrder = c(1,1)),
mean.model     = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = dist
)
}
# Rola previsões fora-da-amostra
specs <- list(
eg_norm = .egarch_spec("norm"),
eg_std  = .egarch_spec("std"),
gj_norm = .gjr_spec("norm"),
gj_std  = .gjr_spec("std")
)
# Se .roll_try não existir, define-o
if (!exists(".roll_try")) {
.roll_try <- function(spec) {
try(
ugarchroll(
spec, data = ret_all, n.ahead = 1,
n.start = n.start,
refit.every = cfg_garch$refit_every %||% 5L,
refit.window = "expanding",
calculate.VaR = FALSE, keep.coef = TRUE,
solver = "hybrid",
parallel = isTRUE(cfg_garch$parallel)
),
silent = TRUE
)
}
}
# Se extract_sigma não existir, define-o
if (!exists("extract_sigma")) {
extract_sigma <- function(roll_obj) {
df <- try(as.data.frame(roll_obj), silent = TRUE)
if (inherits(df, "try-error")) return(NULL)
idx <- suppressWarnings(as.Date(df$Index))
if (all(is.na(idx))) idx <- suppressWarnings(as.Date(rownames(df)))
if (all(is.na(idx))) return(NULL)
tibble::tibble(data = idx, Sigma = as.numeric(df$Sigma))
}
}
res <- lapply(specs, .roll_try)
source("G:/My Drive/Faculdade/6 Periodo/Análise Quantitativa/Trabalho Final/GARCHBOVA11/Pipeline_vol.R", echo = TRUE)
source("G:/My Drive/Faculdade/6 Periodo/Análise Quantitativa/Trabalho Final/GARCHBOVA11/Pipeline_vol.R", echo = TRUE)
source("G:/My Drive/Faculdade/6 Periodo/Análise Quantitativa/Trabalho Final/GARCHBOVA11/Pipeline_vol.R", echo = TRUE)
map_ret_to_peso <- function(nm){
nm <- as.character(nm)
out <- nm
ew_mask <- grepl("^retEW", nm)
out[ew_mask]  <- sub("^retEW", "wEW", nm[ew_mask])
out[!ew_mask] <- sub("^ret_",  "w_",  nm[!ew_mask])
out
}
meta <- dplyr::rename(param_map, serie = serie_peso) |>
dplyr::mutate(serie = sub("^w", "ret", serie))
sens_tbl <- dplyr::left_join(
dplyr::select(metrics_all, serie, ann_ret, ann_vol, sharpe, sortino, mdd, calmar, n, grupo),
meta, by = "serie"
)
readr::write_csv(sens_tbl, "saídas/tabelas/sensitivity_full.csv")
oos_c <- dplyr::filter(metrics_all, grupo == "VT_OOS_c/ct", grepl("_c\\d+$", serie))
oos_c <- oos_c |>
dplyr::mutate(cost_bps = as.integer(sub(".*_c(\\d+)$", "\\1", serie)),
serie_peso = map_ret_to_peso(serie)) |>
dplyr::left_join(dplyr::select(param_map, serie_peso, modelo, alvo_aa, cap), by = "serie_peso")
best_cost_cap <- oos_c |>
dplyr::filter(!is.na(cap), !is.na(cost_bps)) |>
dplyr::group_by(modelo, cost_bps, cap) |>
dplyr::slice_max(order_by = sharpe, n = 1, with_ties = FALSE) |>
dplyr::ungroup()
readr::write_csv(best_cost_cap, "saídas/tabelas/sensitivity_best_by_cost_cap.csv")
best_cost <- oos_c |>
dplyr::filter(!is.na(cost_bps)) |>
dplyr::group_by(modelo, cost_bps) |>
dplyr::slice_max(order_by = sharpe, n = 1, with_ties = FALSE) |>
dplyr::ungroup()
readr::write_csv(best_cost, "saídas/tabelas/sensitivity_best_by_cost.csv")
metrics_all
tabelas_metricas <- function(base_ext, ret_sync, ret_sync_cost, ret_oos, ret_oos_cost, ret_bench, param_map){
rf_vec <- dplyr::coalesce(base_ext$rf_diaria, 0)
vt_sync_nc <- grep("^ret_", names(ret_sync), value = TRUE)
vt_sync_c  <- grep("^ret_.*_c\\d+$", names(ret_sync_cost), value = TRUE)
vt_oos_nc  <- grep("^ret_", names(ret_oos), value = TRUE)
vt_oos_c   <- grep("^ret_.*_c\\d+$", names(ret_oos_cost), value = TRUE)
bench_cols <- c("ret_bh")
met_bench   <- make_metrics_tbl(ret_bench, bench_cols, rf_vec, "BH")
met_sync_nc <- make_metrics_tbl(ret_sync,  vt_sync_nc,  rf_vec, "VT_sync_s/ct")
met_sync_c  <- make_metrics_tbl(ret_sync_cost, vt_sync_c, rf_vec, "VT_sync_c/ct")
met_oos_nc  <- make_metrics_tbl(ret_oos,   vt_oos_nc,   rf_vec, "VT_OOS_s/ct")
met_oos_c   <- make_metrics_tbl(ret_oos_cost, vt_oos_c, rf_vec, "VT_OOS_c/ct")
metrics_all <- dplyr::bind_rows(met_bench, met_sync_nc, met_sync_c, met_oos_nc, met_oos_c) |>
dplyr::arrange(dplyr::desc(sharpe))
readr::write_rds(metrics_all, "saídas/dados/metrics_all.rds")
readr::write_csv(metrics_all, "saídas/dados/metrics_all.csv")
map_ret_to_peso <- function(nm){
nm <- as.character(nm)
out <- nm
ew_mask <- grepl("^retEW", nm)
out[ew_mask]  <- sub("^retEW", "wEW", nm[ew_mask])
out[!ew_mask] <- sub("^ret_",  "w_",  nm[!ew_mask])
out
}
meta <- dplyr::rename(param_map, serie = serie_peso) |>
dplyr::mutate(serie = sub("^w", "ret", serie))
sens_tbl <- dplyr::left_join(
dplyr::select(metrics_all, serie, ann_ret, ann_vol, sharpe, sortino, mdd, calmar, n, grupo),
meta, by = "serie"
)
readr::write_csv(sens_tbl, "saídas/tabelas/sensitivity_full.csv")
oos_c <- dplyr::filter(metrics_all, grupo == "VT_OOS_c/ct", grepl("_c\\d+$", serie))
oos_c <- oos_c |>
dplyr::mutate(cost_bps = as.integer(sub(".*_c(\\d+)$", "\\1", serie)),
serie_peso = map_ret_to_peso(serie)) |>
dplyr::left_join(dplyr::select(param_map, serie_peso, modelo, alvo_aa, cap), by = "serie_peso")
best_cost_cap <- oos_c |>
dplyr::filter(!is.na(cap), !is.na(cost_bps)) |>
dplyr::group_by(modelo, cost_bps, cap) |>
dplyr::slice_max(order_by = sharpe, n = 1, with_ties = FALSE) |>
dplyr::ungroup()
readr::write_csv(best_cost_cap, "saídas/tabelas/sensitivity_best_by_cost_cap.csv")
best_cost <- oos_c |>
dplyr::filter(!is.na(cost_bps)) |>
dplyr::group_by(modelo, cost_bps) |>
dplyr::slice_max(order_by = sharpe, n = 1, with_ties = FALSE) |>
dplyr::ungroup()
readr::write_csv(best_cost, "saídas/tabelas/sensitivity_best_by_cost.csv")
metrics_all
}
source("Pipeline_vol.R",echo=FALSE)
